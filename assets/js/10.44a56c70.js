(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{309:function(t,v,e){},343:function(t,v,e){"use strict";var _=e(309);e.n(_).a},374:function(t,v,e){"use strict";e.r(v);e(343);var _=e(16),r=Object(_.a)({},function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"flex-布局详解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex-布局详解","aria-hidden":"true"}},[t._v("#")]),t._v(" flex 布局详解")]),t._v(" "),e("h2",{attrs:{id:"flex弹性盒模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex弹性盒模型","aria-hidden":"true"}},[t._v("#")]),t._v(" flex弹性盒模型")]),t._v(" "),e("flexlayout-flexBox"),t._v(" "),e("h2",{attrs:{id:"属性解释"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#属性解释","aria-hidden":"true"}},[t._v("#")]),t._v(" 属性解释")]),t._v(" "),e("h3",{attrs:{id:"flexbox"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flexbox","aria-hidden":"true"}},[t._v("#")]),t._v(" flexbox")]),t._v(" "),e("p",[t._v("对于某个元素只要声明了"),e("code",[t._v("display: flex")]),t._v(" 或者 "),e("code",[t._v("display:inline-flex")]),t._v("，那么这个元素就成为了弹性容器，具有flex弹性布局的特性。")]),t._v(" "),e("p",[t._v("flex布局是一种一维布局模型，一次只能处理一个维度（一行或者一列）上的元素布局,也就是说，"),e("strong",[t._v("flex布局大部分的属性都是作用于主轴的，在交叉轴上很多时候只能被动地变化")]),t._v("。")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("容器属性")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th"),t._v(" "),e("th"),t._v(" "),e("th"),t._v(" "),e("th"),t._v(" "),e("th"),t._v(" "),e("th")])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("flex-direction")]),t._v(" "),e("td",[t._v("flex-wrap")]),t._v(" "),e("td",[t._v("flex-flow")]),t._v(" "),e("td",[t._v("justify-content")]),t._v(" "),e("td",[t._v("align-items")]),t._v(" "),e("td",[t._v("align-content")])])])])]),t._v(" "),e("li",[e("p",[t._v("元素属性")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th"),t._v(" "),e("th"),t._v(" "),e("th"),t._v(" "),e("th"),t._v(" "),e("th"),t._v(" "),e("th")])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("order")]),t._v(" "),e("td",[t._v("flex-grow")]),t._v(" "),e("td",[t._v("flex-shrink")]),t._v(" "),e("td",[t._v("flex-basis")]),t._v(" "),e("td",[t._v("flex")]),t._v(" "),e("td",[t._v("align-self")])])])])])]),t._v(" "),e("ol",[e("li",[t._v("每个弹性容器都有两根轴："),e("strong",[t._v("主轴和交叉轴")]),t._v("，两轴之间成90度关系。")]),t._v(" "),e("li",[t._v("每根轴都有 "),e("strong",[t._v("起点")]),t._v(" 和 "),e("strong",[t._v("终点")]),t._v("，这对于元素的对齐非常重要。")]),t._v(" "),e("li",[t._v("弹性容器中的所有子元素称为<弹性元素>，"),e("strong",[t._v("弹性元素永远沿主轴排列")]),t._v("。")]),t._v(" "),e("li",[t._v("弹性元素也可以通过"),e("code",[t._v("display:flex")]),t._v("设置为另一个弹性容器，形成嵌套关系。")])]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("注意")]),e("br"),t._v("水平的不一定就是主轴。"),e("br"),t._v(" 一个元素既可以是弹性容器也可以是弹性元素。")])]),t._v(" "),e("h3",{attrs:{id:"flex-direction-主轴的方向设置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex-direction-主轴的方向设置","aria-hidden":"true"}},[t._v("#")]),t._v(" flex-direction (主轴的方向设置)")]),t._v(" "),e("p",[t._v("我们可以在弹性容器上通过 "),e("code",[t._v("flex-direction")]),t._v(" 修改主轴沿着主轴（Main Axis）(父容器) 的排列方向。弹性元素的排列方式也会发生改变，因为"),e("strong",[t._v("弹性元素永远沿主轴排列")]),t._v("。\n"),e("flexlayout-flexDirection")],1),t._v(" "),e("ul",[e("li",[e("strong",[t._v("row")]),t._v(" ： 水平（顺）")]),t._v(" "),e("li",[e("strong",[t._v("column")]),t._v(" ： 垂直（顺）")]),t._v(" "),e("li",[e("strong",[t._v("row-reverse")]),t._v(" ： 水平（逆）")]),t._v(" "),e("li",[e("strong",[t._v("column-reverse")]),t._v(" ： 垂直（逆）")])]),t._v(" "),e("h3",{attrs:{id:"flex-wrap-沿主轴的排列处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex-wrap-沿主轴的排列处理","aria-hidden":"true"}},[t._v("#")]),t._v(" flex-wrap (沿主轴的排列处理)")]),t._v(" "),e("p",[t._v("弹性元素永远沿主轴排列，如果主轴排不下通过设置 "),e("code",[t._v("flex-wrap: nowrap | wrap | wrap-reverse")]),t._v(" 可使得主轴上的元素不折行、折行、反向折行。"),e("strong",[t._v("默认不折行")]),e("code",[t._v("nowrap")]),t._v("。")]),t._v(" "),e("flexlayout-flexWrap"),t._v(" "),e("ul",[e("li",[e("strong",[t._v("nowrap")]),t._v(" ： 不折行\n"),e("ul",[e("li",[t._v("子元素多的情况下是不会直接溢出父容器，这里就涉及到元素的"),e("strong",[t._v("弹性伸缩应对")])])])]),t._v(" "),e("li",[e("strong",[t._v("wrap")]),t._v(" ： 正向折行\n"),e("ul",[e("li",[t._v("顾名思义就是另起一行，那么折行之后行与行之间的间距（对齐）怎样调整？这里又涉及到"),e("strong",[t._v("交叉轴上的多行对齐")])])])]),t._v(" "),e("li",[e("strong",[t._v("wrap-reverse")]),t._v(" ： 反向折行\n"),e("ul",[e("li",[t._v("是从容器底部开始的折行，但每行元素之间的排列仍保留正向")])])])]),t._v(" "),e("h3",{attrs:{id:"flex-flow-组合-复合属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex-flow-组合-复合属性","aria-hidden":"true"}},[t._v("#")]),t._v(" flex-flow (组合/复合属性)")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("flex-direction")]),t._v(" 和 "),e("code",[t._v("flex-wrap")]),t._v(" 两个属性的排列组合。"),e("code",[t._v("组合/复合属性")])]),t._v(" "),e("li",[t._v("flex-flow = flex-drection + flex-wrap")]),t._v(" "),e("li",[e("code",[t._v("flex-flow")]),t._v(" 相当于规定了flex布局的“工作流(flow)”")])]),t._v(" "),e("div",{staticClass:"language-scss extra-class"},[e("pre",{pre:!0,attrs:{class:"language-scss"}},[e("code",[e("span",{pre:!0,attrs:{class:"token selector"}},[t._v(".wrap ")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token property"}},[t._v("flex-flow")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" row nowrap"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("div",{staticClass:"tip custom-block"},[e("p",[e("code",[t._v("flex 布局")]),t._v(" 文档还在陆续写作中，先上传部分")])]),t._v(" "),e("comment-comment")],1)},[],!1,null,null,null);v.default=r.exports}}]);