(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{309:function(t,v,_){},343:function(t,v,_){"use strict";var e=_(309);_.n(e).a},374:function(t,v,_){"use strict";_.r(v);_(343);var e=_(16),r=Object(e.a)({},function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"flex-布局详解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#flex-布局详解","aria-hidden":"true"}},[t._v("#")]),t._v(" flex 布局详解")]),t._v(" "),_("h2",{attrs:{id:"flex弹性盒模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#flex弹性盒模型","aria-hidden":"true"}},[t._v("#")]),t._v(" flex弹性盒模型")]),t._v(" "),_("flexlayout-flexBox"),t._v(" "),_("h2",{attrs:{id:"属性解释"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#属性解释","aria-hidden":"true"}},[t._v("#")]),t._v(" 属性解释")]),t._v(" "),_("h3",{attrs:{id:"flexbox"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#flexbox","aria-hidden":"true"}},[t._v("#")]),t._v(" flexbox")]),t._v(" "),_("p",[t._v("对于某个元素只要声明了"),_("code",[t._v("display: flex")]),t._v(" 或者 "),_("code",[t._v("display:inline-flex")]),t._v("，那么这个元素就成为了弹性容器，具有flex弹性布局的特性。"),_("br"),t._v("\nflex布局是一种一维布局模型，一次只能处理一个维度（一行或者一列）上的元素布局。"),_("br"),t._v("\n也就是说，"),_("strong",[t._v("flex布局大部分的属性都是作用于主轴的，在交叉轴上很多时候只能被动地变化")]),t._v("。")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("容器属性")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th"),t._v(" "),_("th"),t._v(" "),_("th"),t._v(" "),_("th"),t._v(" "),_("th"),t._v(" "),_("th")])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("flex-direction")]),t._v(" "),_("td",[t._v("flex-wrap")]),t._v(" "),_("td",[t._v("flex-flow")]),t._v(" "),_("td",[t._v("justify-content")]),t._v(" "),_("td",[t._v("align-items")]),t._v(" "),_("td",[t._v("align-content")])])])])]),t._v(" "),_("li",[_("p",[t._v("元素属性")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th"),t._v(" "),_("th"),t._v(" "),_("th"),t._v(" "),_("th"),t._v(" "),_("th"),t._v(" "),_("th")])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("order")]),t._v(" "),_("td",[t._v("flex-grow")]),t._v(" "),_("td",[t._v("flex-shrink")]),t._v(" "),_("td",[t._v("flex-basis")]),t._v(" "),_("td",[t._v("flex")]),t._v(" "),_("td",[t._v("align-self")])])])])])]),t._v(" "),_("ol",[_("li",[t._v("每个弹性容器都有两根轴："),_("strong",[t._v("主轴和交叉轴")]),t._v("，两轴之间成90度关系。")]),t._v(" "),_("li",[t._v("每根轴都有 "),_("strong",[t._v("起点")]),t._v(" 和 "),_("strong",[t._v("终点")]),t._v("，这对于元素的对齐非常重要。")]),t._v(" "),_("li",[t._v("弹性容器中的所有子元素称为<弹性元素>，"),_("strong",[t._v("弹性元素永远沿主轴排列")]),t._v("。")]),t._v(" "),_("li",[t._v("弹性元素也可以通过"),_("code",[t._v("display:flex")]),t._v("设置为另一个弹性容器，形成嵌套关系。")])]),t._v(" "),_("p",[_("strong",[t._v("注意")])]),t._v(" "),_("div",{staticClass:"tip custom-block"},[_("p",[t._v("水平的不一定就是主轴。"),_("br"),t._v(" 一个元素既可以是弹性容器也可以是弹性元素。"),_("br"),t._v("使用flex布局，容器内元素即flex item的"),_("code",[t._v("float")]),t._v("，"),_("code",[t._v("clear")]),t._v("、"),_("code",[t._v("vertical-align")]),t._v("属性将失效。")])]),t._v(" "),_("h3",{attrs:{id:"flex-direction-主轴的方向设置"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#flex-direction-主轴的方向设置","aria-hidden":"true"}},[t._v("#")]),t._v(" flex-direction (主轴的方向设置)")]),t._v(" "),_("p",[t._v("我们可以在弹性容器上通过 "),_("code",[t._v("flex-direction")]),t._v(" 决定主轴的方向，即项目排列的方向。"),_("br"),t._v("\n弹性元素的排列方式也会发生改变，因为"),_("strong",[t._v("弹性元素永远沿主轴排列")]),t._v("。")]),t._v(" "),_("flexlayout-flexDirection"),t._v(" "),_("ul",[_("li",[_("strong",[t._v("row")]),t._v(" ： 主轴为水平方向，项目沿主轴从左至右排列")]),t._v(" "),_("li",[_("strong",[t._v("column")]),t._v(" ： 主轴为竖直方向，项目沿主轴从上至下排列")]),t._v(" "),_("li",[_("strong",[t._v("row-reverse")]),t._v(" ： 主轴水平，项目从右至左排列，与row反向")]),t._v(" "),_("li",[_("strong",[t._v("column-reverse")]),t._v(" ： 主轴竖直，项目从下至上排列，与column反向")])]),t._v(" "),_("h3",{attrs:{id:"flex-wrap-沿主轴的排列处理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#flex-wrap-沿主轴的排列处理","aria-hidden":"true"}},[t._v("#")]),t._v(" flex-wrap (沿主轴的排列处理)")]),t._v(" "),_("p",[t._v("默认情况下，item在主轴上排列成一条线，即"),_("strong",[t._v("弹性元素永远沿主轴排列")]),_("br"),t._v("\n通过设置"),_("strong",[t._v("flex-wrap: nowrap | wrap | wrap-reverse")]),t._v("决定当排列不下时是否换行以及换行的方式"),_("br"),t._v("\n可使得主轴上的元素"),_("code",[t._v("不折行")]),t._v(" 、 "),_("code",[t._v("折行")]),t._v(" 、 "),_("code",[t._v("反向折行")]),t._v(" 。默认不折行 nowrap 。")]),t._v(" "),_("flexlayout-flexWrap"),t._v(" "),_("ul",[_("li",[_("strong",[t._v("nowrap")]),t._v(" ： 自动缩小项目，不折行\n"),_("ul",[_("li",[t._v("子元素多的情况下是不会直接溢出父容器，这里就涉及到元素的"),_("strong",[t._v("弹性伸缩应对")])])])]),t._v(" "),_("li",[_("strong",[t._v("wrap")]),t._v(" ： 折行，且第一行在上方\n"),_("ul",[_("li",[t._v("顾名思义就是另起一行，那么折行之后行与行之间的间距（对齐）怎样调整？这里又涉及到"),_("strong",[t._v("交叉轴上的多行对齐")])])])]),t._v(" "),_("li",[_("strong",[t._v("wrap-reverse")]),t._v(" ： 折行，第一行在下面\n"),_("ul",[_("li",[t._v("是从容器底部开始的折行，但每行元素之间的排列仍保留正向")])])])]),t._v(" "),_("h3",{attrs:{id:"flex-flow-组合-复合属性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#flex-flow-组合-复合属性","aria-hidden":"true"}},[t._v("#")]),t._v(" flex-flow (组合/复合属性)")]),t._v(" "),_("ul",[_("li",[t._v("flex-flow = flex-drection + flex-wrap")]),t._v(" "),_("li",[_("code",[t._v("flex-direction")]),t._v(" 和 "),_("code",[t._v("flex-wrap")]),t._v(" 两个属性的排列组合。"),_("code",[t._v("组合/复合属性")])]),t._v(" "),_("li",[_("code",[t._v("flex-flow")]),t._v(" 相当于规定了flex布局的“工作流(flow)”")])]),t._v(" "),_("div",{staticClass:"language-scss extra-class"},[_("pre",{pre:!0,attrs:{class:"language-scss"}},[_("code",[_("span",{pre:!0,attrs:{class:"token selector"}},[t._v(".wrap ")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token property"}},[t._v("flex-flow")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" row nowrap"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),t._v(" "),_("div",{staticClass:"tip custom-block"},[_("p",[_("code",[t._v("flex 布局")]),t._v(" 文档还在陆续写作中，未完待续。。。")])]),t._v(" "),_("comment-comment")],1)},[],!1,null,null,null);v.default=r.exports}}]);