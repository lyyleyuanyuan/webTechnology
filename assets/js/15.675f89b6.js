(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{309:function(v,_,e){},348:function(v,_,e){"use strict";var t=e(309);e.n(t).a},392:function(v,_,e){"use strict";e.r(_);e(348);var t=e(16),r=Object(t.a)({},function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"flex-布局详解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex-布局详解","aria-hidden":"true"}},[v._v("#")]),v._v(" flex 布局详解")]),v._v(" "),e("h2",{attrs:{id:"flex弹性盒模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex弹性盒模型","aria-hidden":"true"}},[v._v("#")]),v._v(" flex弹性盒模型")]),v._v(" "),e("flexlayout-flexBox"),v._v(" "),e("h3",{attrs:{id:"flexbox"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flexbox","aria-hidden":"true"}},[v._v("#")]),v._v(" flexbox")]),v._v(" "),e("p",[v._v("对于某个元素只要声明了"),e("code",[v._v("display: flex")]),v._v(" 或者 "),e("code",[v._v("display:inline-flex")]),v._v("，那么这个元素就成为了弹性容器，具有flex弹性布局的特性。"),e("br"),v._v("\nflex布局是一种一维布局模型，一次只能处理一个维度（一行或者一列）上的元素布局。"),e("br"),v._v("\n也就是说，"),e("strong",[v._v("flex布局大部分的属性都是作用于主轴的，在交叉轴上很多时候只能被动地变化")]),v._v("。")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("容器属性")]),v._v(" "),e("table",[e("thead",[e("tr",[e("th"),v._v(" "),e("th"),v._v(" "),e("th"),v._v(" "),e("th"),v._v(" "),e("th"),v._v(" "),e("th")])]),v._v(" "),e("tbody",[e("tr",[e("td",[v._v("flex-direction")]),v._v(" "),e("td",[v._v("flex-wrap")]),v._v(" "),e("td",[v._v("flex-flow")]),v._v(" "),e("td",[v._v("justify-content")]),v._v(" "),e("td",[v._v("align-items")]),v._v(" "),e("td",[v._v("align-content")])])])])]),v._v(" "),e("li",[e("p",[v._v("元素属性")]),v._v(" "),e("table",[e("thead",[e("tr",[e("th"),v._v(" "),e("th"),v._v(" "),e("th"),v._v(" "),e("th"),v._v(" "),e("th"),v._v(" "),e("th")])]),v._v(" "),e("tbody",[e("tr",[e("td",[v._v("order")]),v._v(" "),e("td",[v._v("flex-grow")]),v._v(" "),e("td",[v._v("flex-shrink")]),v._v(" "),e("td",[v._v("flex-basis")]),v._v(" "),e("td",[v._v("flex")]),v._v(" "),e("td",[v._v("align-self")])])])])])]),v._v(" "),e("ol",[e("li",[v._v("每个弹性容器都有两根轴："),e("strong",[v._v("主轴和交叉轴")]),v._v("，两轴之间成90度关系。")]),v._v(" "),e("li",[v._v("每根轴都有 "),e("strong",[v._v("起点")]),v._v(" 和 "),e("strong",[v._v("终点")]),v._v("，这对于元素的对齐非常重要。")]),v._v(" "),e("li",[v._v("弹性容器中的所有子元素称为<弹性元素>，"),e("strong",[v._v("弹性元素永远沿主轴排列")]),v._v("。")]),v._v(" "),e("li",[v._v("弹性元素也可以通过"),e("code",[v._v("display:flex")]),v._v("设置为另一个弹性容器，形成嵌套关系。")])]),v._v(" "),e("p",[e("strong",[v._v("注意")])]),v._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",[v._v("水平的不一定就是主轴。"),e("br"),v._v(" 一个元素既可以是弹性容器也可以是弹性元素。"),e("br"),v._v("使用flex布局，容器内元素即flex item的"),e("code",[v._v("float")]),v._v("，"),e("code",[v._v("clear")]),v._v("、"),e("code",[v._v("vertical-align")]),v._v("属性将失效。")])]),v._v(" "),e("h2",{attrs:{id:"容器属性详解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#容器属性详解","aria-hidden":"true"}},[v._v("#")]),v._v(" 容器属性详解")]),v._v(" "),e("h3",{attrs:{id:"flex-direction-主轴的方向设置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex-direction-主轴的方向设置","aria-hidden":"true"}},[v._v("#")]),v._v(" flex-direction (主轴的方向设置)")]),v._v(" "),e("p",[v._v("我们可以在弹性容器上通过 "),e("code",[v._v("flex-direction")]),v._v(" 决定主轴的方向，即项目排列的方向。"),e("br"),v._v("\n弹性元素的排列方式也会发生改变，因为"),e("strong",[v._v("弹性元素永远沿主轴排列")]),v._v("。")]),v._v(" "),e("flexlayout-flexDirection"),v._v(" "),e("ul",[e("li",[e("strong",[v._v("row")]),v._v(" ： 主轴为水平方向，项目沿主轴从左至右排列")]),v._v(" "),e("li",[e("strong",[v._v("column")]),v._v(" ： 主轴为竖直方向，项目沿主轴从上至下排列")]),v._v(" "),e("li",[e("strong",[v._v("row-reverse")]),v._v(" ： 主轴水平，项目从右至左排列，与row反向")]),v._v(" "),e("li",[e("strong",[v._v("column-reverse")]),v._v(" ： 主轴竖直，项目从下至上排列，与column反向")])]),v._v(" "),e("h3",{attrs:{id:"flex-wrap-沿主轴的排列处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex-wrap-沿主轴的排列处理","aria-hidden":"true"}},[v._v("#")]),v._v(" flex-wrap (沿主轴的排列处理)")]),v._v(" "),e("p",[v._v("默认情况下，item在主轴上排列成一条线，即"),e("strong",[v._v("弹性元素永远沿主轴排列")]),v._v("。"),e("br"),v._v("\n通过设置"),e("strong",[v._v("flex-wrap: nowrap | wrap | wrap-reverse")]),v._v("决定父容器内item当排列不下时是否换行以及换行的方式。"),e("br"),v._v("\n可使得主轴上的元素"),e("code",[v._v("不折行")]),v._v(" 、 "),e("code",[v._v("折行")]),v._v(" 、 "),e("code",[v._v("反向折行")]),v._v(" 。默认不折行 nowrap。\n"),e("flexlayout-flexWrap")],1),v._v(" "),e("ul",[e("li",[e("strong",[v._v("nowrap")]),v._v(" ： 自动缩小项目，不折行\n"),e("ul",[e("li",[v._v("子元素多的情况下是不会直接溢出父容器，这里就涉及到元素的"),e("strong",[v._v("弹性伸缩应对")])])])]),v._v(" "),e("li",[e("strong",[v._v("wrap")]),v._v(" ： 折行，且第一行在上方\n"),e("ul",[e("li",[v._v("顾名思义就是另起一行，那么折行之后行与行之间的间距（对齐）怎样调整？这里又涉及到"),e("strong",[v._v("交叉轴上的多行对齐")])])])]),v._v(" "),e("li",[e("strong",[v._v("wrap-reverse")]),v._v(" ： 折行，第一行在下面\n"),e("ul",[e("li",[v._v("是从容器底部开始的折行，但每行元素之间的排列仍保留正向")])])])]),v._v(" "),e("h3",{attrs:{id:"flex-flow-组合-复合属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex-flow-组合-复合属性","aria-hidden":"true"}},[v._v("#")]),v._v(" flex-flow (组合/复合属性)")]),v._v(" "),e("ul",[e("li",[v._v("flex-flow = flex-drection + flex-wrap")]),v._v(" "),e("li",[e("code",[v._v("flex-direction")]),v._v(" 和 "),e("code",[v._v("flex-wrap")]),v._v(" 两个属性的排列组合。"),e("code",[v._v("组合/复合属性")])]),v._v(" "),e("li",[e("code",[v._v("flex-flow")]),v._v(" 相当于规定了flex布局的“工作流(flow)”。")])]),v._v(" "),e("div",{staticClass:"language-scss extra-class"},[e("pre",{pre:!0,attrs:{class:"language-scss"}},[e("code",[e("span",{pre:!0,attrs:{class:"token selector"}},[v._v(".wrap ")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token property"}},[v._v("flex-flow")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v(" row nowrap"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n")])])]),e("h3",{attrs:{id:"justify-content（主轴上item的对齐方式）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#justify-content（主轴上item的对齐方式）","aria-hidden":"true"}},[v._v("#")]),v._v(" justify-content（主轴上item的对齐方式）")]),v._v(" "),e("p",[v._v("决定父容器内item在主轴上的对齐方式\n"),e("flexlayout-justifyContent")],1),v._v(" "),e("ul",[e("li",[e("strong",[v._v("flex-start")]),v._v(" ：左对齐")]),v._v(" "),e("li",[e("strong",[v._v("flex-end")]),v._v(" ：右对齐")]),v._v(" "),e("li",[e("strong",[v._v("center")]),v._v(" ：居中对齐")]),v._v(" "),e("li",[e("strong",[v._v("space-between")]),v._v(" ：两端对齐")]),v._v(" "),e("li",[e("strong",[v._v("space-around")]),v._v(" ：沿轴线均匀分布")])]),v._v(" "),e("h3",{attrs:{id:"align-items-交叉轴上的单行对齐"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#align-items-交叉轴上的单行对齐","aria-hidden":"true"}},[v._v("#")]),v._v(" align-items (交叉轴上的单行对齐)")]),v._v(" "),e("p",[v._v("决定了父容器内item在交叉轴上的对齐方式。"),e("br"),v._v("\n默认值是stretch，当元素没有设置具体尺寸时会将容器在交叉轴方向撑满。\n"),e("flexlayout-alignItems")],1),v._v(" "),e("p",[e("strong",[v._v("当主轴水平时，其具体含义为")])]),v._v(" "),e("ul",[e("li",[e("strong",[v._v("flex-start")]),v._v(" ：顶端对齐")]),v._v(" "),e("li",[e("strong",[v._v("flex-end")]),v._v(" ：底部对齐")]),v._v(" "),e("li",[e("strong",[v._v("center")]),v._v(" ：竖直方向上居中对齐")]),v._v(" "),e("li",[e("strong",[v._v("baseline")]),v._v(" ：item第一行文字的基线对齐")]),v._v(" "),e("li",[e("strong",[v._v("stretch")]),v._v(" ：当item未设置高度时，item将和父容器等高对齐")])]),v._v(" "),e("h3",{attrs:{id:"align-content-交叉轴上的多行对齐"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#align-content-交叉轴上的多行对齐","aria-hidden":"true"}},[v._v("#")]),v._v(" align-content(交叉轴上的多行对齐)")]),v._v(" "),e("p",[v._v("当有多根主轴时即item不止一行时，多行在交叉轴轴上的对齐方式,如果只有一行，该属性不起作用。 "),e("br"),v._v(" "),e("strong",[v._v("只对多行元素有效")]),v._v("，会以多行作为整体进行对齐，"),e("strong",[v._v("容器必须开启换行")]),v._v("。"),e("br"),v._v("\n必须设置 "),e("code",[v._v("flex-wrap")]),v._v(" 属性为 "),e("code",[v._v("wrap")]),v._v(" 或者 "),e("code",[v._v("wrap-reverse")]),e("br"),v._v("\n定义了align-content后，align-items属性将失效。\n"),e("flexlayout-alignContent")],1),v._v(" "),e("p",[e("strong",[v._v("当主轴水平时，其具体含义为")])]),v._v(" "),e("ul",[e("li",[e("strong",[v._v("flex-start")]),v._v(" ：左对齐")]),v._v(" "),e("li",[e("strong",[v._v("flex-end")]),v._v(" ：右对齐")]),v._v(" "),e("li",[e("strong",[v._v("center")]),v._v(" ：居中对齐")]),v._v(" "),e("li",[e("strong",[v._v("space-between")]),v._v(" ：两端对齐")]),v._v(" "),e("li",[e("strong",[v._v("space-around")]),v._v(" ：沿轴线均匀分布")]),v._v(" "),e("li",[e("strong",[v._v("stretch")]),v._v(" ：各行将根据其flex-grow值伸展以充分占据剩余空间")])]),v._v(" "),e("h2",{attrs:{id:"元素属性详解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#元素属性详解","aria-hidden":"true"}},[v._v("#")]),v._v(" 元素属性详解")]),v._v(" "),e("h3",{attrs:{id:"order"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#order","aria-hidden":"true"}},[v._v("#")]),v._v(" order")]),v._v(" "),e("p",[v._v("order的值是整数，默认为0，整数越小，item排列越靠前。"),e("br"),v._v("\n值相同时，以dom中元素排列为准。\n"),e("flexlayout-order")],1),v._v(" "),e("div",{staticClass:"language-scss extra-class"},[e("pre",{pre:!0,attrs:{class:"language-scss"}},[e("code",[e("span",{pre:!0,attrs:{class:"token selector"}},[v._v(".item ")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token property"}},[v._v("order")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v(" 0"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n")])])]),e("h3",{attrs:{id:"flex-grow-放大比例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex-grow-放大比例","aria-hidden":"true"}},[v._v("#")]),v._v(" flex-grow(放大比例)")]),v._v(" "),e("p",[v._v("在flex布局中，父容器剩余宽度默认是不进行分配的，也就是所有弹性元素的"),e("code",[v._v("flex-grow")]),v._v("都为0。"),e("br"),v._v("\n通过指定 "),e("code",[v._v("flex-grow")]),v._v(" 整数值，分配父容器剩余宽度的比例，"),e("strong",[v._v("叠加")]),v._v("到原来item的尺寸上，"),e("strong",[v._v("负值无效")]),v._v("。"),e("br"),v._v(" "),e("strong",[v._v("无多余宽度时，flex-grow无效")]),v._v("。"),e("br")]),v._v(" "),e("ul",[e("li",[e("strong",[v._v("计算方法")]),v._v(" "),e("ul",[e("li",[v._v("容器剩余宽度：50px")]),v._v(" "),e("li",[v._v("分成每份：50px / (3+2) = 10px")]),v._v(" "),e("li",[v._v("元素1放大为：50px + 3 * 10 = 80px")])])])]),v._v(" "),e("flexlayout-flexGrow"),v._v(" "),e("h3",{attrs:{id:"flex-shrink-缩小比例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex-shrink-缩小比例","aria-hidden":"true"}},[v._v("#")]),v._v(" flex-shrink(缩小比例)")]),v._v(" "),e("p",[e("code",[v._v("flex-shrink")]),v._v(" 默认为1，当父容器宽度不够分配时，元素都将等比例缩小，占满整个宽度。"),e("br"),v._v(" "),e("code",[v._v("flex-shrink: 1")]),v._v(" 并非严格等比缩小，"),e("strong",[v._v("会考虑弹性元素本身的大小")]),v._v("。"),e("br"),v._v("\n一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 "),e("br"),v._v("\n父容器设置的 "),e("code",[v._v("flex-wrap:wrap/wrap-reverse")]),v._v(" 则不存在空间不足的情况，"),e("strong",[v._v("flex-shrink无效")]),v._v("。 "),e("br"),v._v(" "),e("strong",[v._v("负值对该属性无效")]),v._v("。")]),v._v(" "),e("ul",[e("li",[e("strong",[v._v("计算方法")]),v._v(" "),e("ul",[e("li",[v._v("容器剩余宽度：-70px\n"),e("ul",[e("li",[v._v("弹性元素1：50px（→37.03px）")]),v._v(" "),e("li",[v._v("弹性元素2：100px（→74.08px）")]),v._v(" "),e("li",[v._v("弹性元素3：120px（→88.89px）")])])]),v._v(" "),e("li",[v._v("缩小因子的分母：1"),e("em",[v._v("50 + 1")]),v._v("100 + 1*120 = 270 (1为各元素flex-shrink的值)")]),v._v(" "),e("li",[v._v("元素1的缩小因子：1*50/270")]),v._v(" "),e("li",[v._v("元素1的缩小宽度为缩小因子乘于容器剩余宽度：1*50/270 * (-70)")]),v._v(" "),e("li",[v._v("元素1最后则缩小为：50px + (1*50/270 *(-70)) = 37.03px")])])])]),v._v(" "),e("flexlayout-flexShrink"),v._v(" "),e("h3",{attrs:{id:"flex-basis-初始尺寸"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex-basis-初始尺寸","aria-hidden":"true"}},[v._v("#")]),v._v(" flex-basis(初始尺寸)")]),v._v(" "),e("p",[v._v("弹性处理之余，有些元素尺寸需固定不进行弹性调整。除了width和height以外，还可以使用 "),e("code",[v._v("flex-basis")]),v._v(" 属性。"),e("br"),v._v(" "),e("code",[v._v("flex-basis")]),v._v(" 设置的是元素在主轴上的初始尺寸，初始尺寸就是元素在 "),e("code",[v._v("flex-grow")]),v._v(" 和 "),e("code",[v._v("flex-shrink")]),v._v(" 生效前的尺寸。")]),v._v(" "),e("ul",[e("li",[e("strong",[v._v("与width/height的区别")]),v._v(" "),e("ul",[e("li",[e("strong",[v._v("两者都为0")]),v._v(" "),e("ul",[e("li",[v._v("width: 0 ; —— 完全没显示")]),v._v(" "),e("li",[v._v("flex-basis: 0 ; —— 根据内容撑开宽度")])])]),v._v(" "),e("li",[e("strong",[v._v("两者非0")]),v._v(" "),e("ul",[e("li",[v._v("—— 数值相同时两者等效")]),v._v(" "),e("li",[v._v("—— 同时设置，flex-basis优先级高")])])]),v._v(" "),e("li",[e("strong",[v._v("flex-basis为auto")]),v._v(" "),e("ul",[e("li",[v._v("flex-basis为auto时，如设置了width则元素尺寸由width决定；没有设置则由内容决定\n\x3c!-- + flex-basis == 主轴上的尺寸 != width")]),v._v(" "),e("li",[v._v("将主轴方向改为：上→下")]),v._v(" "),e("li",[v._v("此时主轴上的尺寸是元素的height")]),v._v(" "),e("li",[v._v("flex-basis == height --\x3e")])])])])])]),v._v(" "),e("h3",{attrs:{id:"flex-复合属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flex-复合属性","aria-hidden":"true"}},[v._v("#")]),v._v(" flex(复合属性)")]),v._v(" "),e("p",[v._v("flex = flex-grow + flex-shrink + flex-basis。"),e("br"),v._v(" "),e("code",[v._v("flex")]),v._v(" 属性是 "),e("code",[v._v("flex-grow")]),v._v(" 、 "),e("code",[v._v("flex-shrink")]),v._v(" 和 "),e("code",[v._v("flex-basis")]),v._v(" 三属性的简写总和。"),e("br"),v._v("\n默认值为0 1 auto。"),e("br"),v._v("\n该属性有两个快捷写法："),e("strong",[e("code",[v._v("auto")]),v._v("（1 1 auto）")]),v._v(" 和 "),e("strong",[e("code",[v._v("none")]),v._v("（0 0 auto）")]),v._v("。"),e("br")]),v._v(" "),e("ul",[e("li",[e("strong",[v._v("快捷写法")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("flex: 1;")]),v._v(" => "),e("code",[v._v("flex: 1 1 0%;")])]),v._v(" "),e("li",[e("code",[v._v("flex: 2;")]),v._v(" => "),e("code",[v._v("flex: 2 1 0%;")])]),v._v(" "),e("li",[e("code",[v._v("flex: auto;")]),v._v(" => "),e("code",[v._v("flex: 1 1 auto;")])]),v._v(" "),e("li",[e("code",[v._v("flex: none;")]),v._v(" => "),e("code",[v._v("flex: 0 0 auto;")]),v._v(" // 常用于固定尺寸 不伸缩")])])]),v._v(" "),e("li",[e("strong",[v._v("flex:1 和 flex:auto 的区别")]),v._v(" "),e("ul",[e("li",[v._v("其实可以归结于 "),e("code",[v._v("flex-basis:0")]),v._v(" 和 "),e("code",[v._v("flex-basis:auto")]),v._v(" 的区别。")]),v._v(" "),e("li",[e("code",[v._v("flex-basis")]),v._v(" 是指定初始尺寸，当设置为0时（绝对弹性元素），此时相当于告诉 "),e("code",[v._v("flex-grow")]),v._v(" 和 "),e("code",[v._v("flex-shrink")]),v._v(" 在伸缩的时候不需要考虑我的尺寸；相反当设置为auto时（相对弹性元素），此时则需要在伸缩时将元素尺寸纳入考虑。")])])])]),v._v(" "),e("h3",{attrs:{id:"align-self-单独设置对齐方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#align-self-单独设置对齐方式","aria-hidden":"true"}},[v._v("#")]),v._v(" align-self(单独设置对齐方式)")]),v._v(" "),e("p",[e("code",[v._v("align-self")]),v._v(" 单独对某个元素设置交叉轴对齐方式。"),e("br"),v._v("\n值与 "),e("code",[v._v("align-items")]),v._v(" 相同。"),e("br"),v._v("\n可覆盖容器的 "),e("code",[v._v("align-items")]),v._v(" 属性。"),e("br"),v._v("\n默认值为 "),e("code",[v._v("auto")]),v._v(" ，表示继承父元素的 "),e("code",[v._v("align-items")]),v._v(" 属性，如果没有父元素，则等同于stretch。"),e("br"),v._v(" "),e("flexlayout-flexSelf")],1),v._v(" "),e("comment-comment")],1)},[],!1,null,null,null);_.default=r.exports}}]);